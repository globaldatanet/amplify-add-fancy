export declare type FunctionRuntimeContributorFactory = (context: any) => Contributor<FunctionRuntimeParameters, RuntimeContributionRequest> & FunctionRuntimeLifecycleManager;
export declare type FunctionRuntimeParameters = Pick<FunctionParameters, 'runtime'>;
export declare type FunctionTemplateContributorFactory = (context: any) => Contributor<Partial<FunctionParameters>, TemplateContributionRequest>;
export declare type FunctionTemplateParameters = Pick<FunctionParameters, 'dependsOn' | 'functionTemplate' | 'triggerEventSourceMappings'>;
export interface Contributor<T extends Partial<FunctionParameters>, K> {
    contribute(request: K): Promise<T>;
}
export interface FunctionRuntimeLifecycleManager {
    checkDependencies(runtimeValue: string): Promise<CheckDependenciesResult>;
    package(request: PackageRequest): Promise<PackageResult>;
    build(request: BuildRequest): Promise<BuildResult>;
    invoke(request: InvocationRequest): Promise<any>;
}
export declare type TemplateContributionRequest = {
    selection: string;
    contributionContext: {
        runtime: FunctionRuntime;
        functionName: string;
        resourceName: string;
    };
};
export declare type RuntimeContributionRequest = {
    selection: string;
    contributionContext: {
        functionName: string;
        resourceName: string;
    };
};
export declare type InvocationRequest = {
    srcRoot: string;
    runtime: string;
    handler: string;
    event: string;
    envVars?: {
        [key: string]: string;
    };
};
export declare type BuildRequest = {
    buildType: BuildType;
    srcRoot: string;
    runtime: string;
    legacyBuildHookParams?: {
        projectRoot: string;
        resourceName: string;
    };
    lastBuildTimeStamp?: Date;
    lastBuildType?: BuildType;
    service?: string;
};
export declare enum BuildType {
    PROD = "PROD",
    DEV = "DEV"
}
export declare type PackageRequest = {
    env: string;
    srcRoot: string;
    dstFilename: string;
    runtime: string;
    lastBuildTimeStamp: Date;
    lastPackageTimeStamp?: Date;
    skipHashing?: boolean;
    service?: string;
    currentHash?: boolean;
};
export declare type BuildResult = {
    rebuilt: boolean;
};
export declare type PackageResult = {
    packageHash?: string;
    zipEntries?: ZipEntry[];
};
export declare type ZipEntry = {
    sourceFolder?: string;
    packageFolder?: string;
    ignoreFiles?: string[];
};
export declare type CheckDependenciesResult = {
    hasRequiredDependencies: boolean;
    errorMessage?: string;
};
export declare type FunctionParameters = {
    providerContext: ProviderContext;
    cloudResourceTemplatePath: string;
    resourceName: string;
    functionName: string;
    runtime: FunctionRuntime;
    roleName: string;
    dependsOn?: FunctionDependency[];
    functionTemplate?: FunctionTemplate;
    categoryPolicies?: object[];
    skipEdit?: boolean;
    mutableParametersState?: any;
    environmentMap?: Record<string, any>;
    triggerEventSourceMappings?: any;
    topLevelComment?: string;
    runtimePluginId: string;
    cloudwatchRule?: string;
    lambdaLayers: LambdaLayer[];
    environmentVariables?: Record<string, string>;
    secretDeltas?: SecretDeltas;
};
export interface FunctionTriggerParameters {
    trigger: boolean;
    key: string;
    modules: any[];
    parentResource: string;
    functionName: string;
    resourceName: string;
    parentStack: string;
    triggerEnvs: any;
    triggerIndexPath: string;
    triggerPackagePath: string;
    triggerDir: string;
    roleName: string;
    triggerTemplate: string;
    triggerEventPath: string;
    skipEdit: boolean;
    functionTemplate?: FunctionTemplate;
    cloudResourceTemplatePath?: string;
    environmentVariables?: Record<string, string>;
}
export interface ProviderContext {
    provider: string;
    service: string;
    projectName: string;
}
export interface FunctionRuntime {
    name: string;
    value: string;
    cloudTemplateValue: string;
    defaultHandler: string;
    layerExecutablePath?: string;
    layerDefaultFiles?: LayerFiles[];
    runtimePluginId?: string;
}
export interface LayerFiles {
    path: string;
    filename: string;
    content?: any;
}
export interface FunctionTemplate {
    handler?: string;
    parameters?: any;
    sourceRoot: string;
    sourceFiles: string[];
    destMap?: {
        [name: string]: string;
    };
    defaultEditorFile?: string;
}
export interface FunctionDependency {
    category: string;
    resourceName: string;
    attributes: string[];
    attributeEnvMap?: {
        [name: string]: string;
    };
}
export declare type LambdaLayer = ProjectLayer | ExternalLayer;
export interface ProjectLayer {
    type: 'ProjectLayer';
    resourceName: string;
    version: number | string;
    isLatestVersionSelected: boolean;
    env: string;
}
export interface ExternalLayer {
    type: 'ExternalLayer';
    arn: string | {
        'Fn::Sub': string;
    } | {
        Ref: string;
    };
}
interface FunctionContributorCondition {
    provider?: string;
    services?: Array<string>;
    runtime?: string | Array<string>;
}
export declare type FunctionTemplateCondition = FunctionContributorCondition;
export declare type FunctionRuntimeCondition = Pick<FunctionContributorCondition, 'provider' | 'services'>;
export interface FunctionBreadcrumbs {
    pluginId: string;
    functionRuntime: string;
    useLegacyBuild: boolean;
    defaultEditorFile: string;
    scripts?: Record<'build' & 'package', FunctionScript>;
}
export interface FunctionScript {
    type: 'file' | 'inline';
    value: string;
}
export declare type SecretDeltas = Record<SecretName, SecretDelta>;
export declare type SecretName = string;
export declare type SecretDelta = RetainSecret | RemoveSecret | SetSecret;
export declare type RetainSecret = {
    operation: 'retain';
};
export declare const retainSecret: RetainSecret;
export declare type RemoveSecret = {
    operation: 'remove';
};
export declare const removeSecret: RemoveSecret;
export declare type SetSecret = {
    operation: 'set';
    value: string;
};
export declare const setSecret: (value: string) => SetSecret;
export {};
//# sourceMappingURL=index.d.ts.map