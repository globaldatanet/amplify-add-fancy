"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLocalFunctionSecretNames = exports.storeSecretsPendingRemoval = exports.FunctionSecretsStateManager = void 0;
const amplify_cli_core_1 = require("amplify-cli-core");
const amplify_function_plugin_interface_1 = require("amplify-function-plugin-interface");
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const constants_1 = require("../../../constants");
const secretValuesWalkthrough_1 = require("../service-walkthroughs/secretValuesWalkthrough");
const cloudformationHelpers_1 = require("../utils/cloudformationHelpers");
const constants_2 = require("../utils/constants");
const funcionStateUtils_1 = require("../utils/funcionStateUtils");
const storeResources_1 = require("../utils/storeResources");
const updateTopLevelComment_1 = require("../utils/updateTopLevelComment");
const secretDeltaUtilities_1 = require("./secretDeltaUtilities");
const secretName_1 = require("./secretName");
const secretsCfnModifier_1 = require("./secretsCfnModifier");
const ssmClientWrapper_1 = require("./ssmClientWrapper");
const lodash_1 = __importDefault(require("lodash"));
let secretsPendingRemoval = {};
class FunctionSecretsStateManager {
    constructor(context, ssmClientWrapper) {
        this.context = context;
        this.ssmClientWrapper = ssmClientWrapper;
        this.syncSecretDeltas = async (secretDeltas, functionName, envName) => {
            if (!secretDeltas) {
                return;
            }
            await Promise.all(Object.entries(secretDeltas).map(async ([secretName, secretDelta]) => {
                const fullyQualifiedSecretName = secretName_1.getFullyQualifiedSecretName(secretName, functionName, envName);
                switch (secretDelta.operation) {
                    case 'remove':
                        if (this.doRemoveSecretsInCloud(functionName)) {
                            await this.ssmClientWrapper.deleteSecret(fullyQualifiedSecretName);
                        }
                        break;
                    case 'set':
                        await this.ssmClientWrapper.setSecret(fullyQualifiedSecretName, secretDelta.value);
                }
            }));
            try {
                const origTemplate = await cloudformationHelpers_1.getFunctionCloudFormationTemplate(functionName);
                const newTemplate = await secretsCfnModifier_1.updateSecretsInCfnTemplate(origTemplate, secretDeltas, functionName);
                await cloudformationHelpers_1.setFunctionCloudFormationTemplate(functionName, newTemplate);
            }
            catch (err) {
                if (secretDeltaUtilities_1.hasExistingSecrets(secretDeltas)) {
                    throw err;
                }
            }
            await updateTopLevelComment_1.tryPrependSecretsUsageExample(functionName, Object.keys(secretDeltaUtilities_1.getExistingSecrets(secretDeltas)));
            await setLocalFunctionSecretState(functionName, secretDeltas);
        };
        this.ensureNewLocalSecretsSyncedToCloud = async (functionName) => {
            const localSecretNames = exports.getLocalFunctionSecretNames(functionName);
            if (!localSecretNames.length) {
                return;
            }
            const cloudSecretNames = await this.getCloudFunctionSecretNames(functionName);
            const addedSecrets = localSecretNames.filter(name => !cloudSecretNames.includes(name));
            if (!addedSecrets.length) {
                return;
            }
            if (!this.isInteractive()) {
                throw new Error(`The following secrets in ${functionName} do not have values: [${addedSecrets}]\nRun 'amplify push' interactively to specify values.`);
            }
            const delta = await secretValuesWalkthrough_1.prePushMissingSecretsWalkthrough(functionName, addedSecrets);
            await this.syncSecretDeltas(delta, functionName);
        };
        this.deleteAllFunctionSecrets = async (functionName) => {
            const cloudSecretNames = await this.getCloudFunctionSecretNames(functionName);
            await this.syncSecretDeltas(secretDeltaUtilities_1.secretNamesToSecretDeltas(cloudSecretNames, amplify_function_plugin_interface_1.removeSecret), functionName);
        };
        this.syncSecretsPendingRemoval = async () => {
            await Promise.all(Object.entries(secretsPendingRemoval).map(([functionName, secretNames]) => this.syncSecretDeltas({
                ...secretDeltaUtilities_1.secretNamesToSecretDeltas(exports.getLocalFunctionSecretNames(functionName)),
                ...secretDeltaUtilities_1.secretNamesToSecretDeltas(secretNames, amplify_function_plugin_interface_1.removeSecret),
            }, functionName)));
            secretsPendingRemoval = {};
        };
        this.deleteAllEnvironmentSecrets = async (envName) => {
            const secretNames = await this.ssmClientWrapper.getSecretNamesByPath(secretName_1.getEnvSecretPrefix(envName));
            await this.ssmClientWrapper.deleteSecrets(secretNames);
        };
        this.getEnvCloneDeltas = async (sourceEnv, functionName) => {
            const destDelta = secretDeltaUtilities_1.secretNamesToSecretDeltas(exports.getLocalFunctionSecretNames(functionName), amplify_function_plugin_interface_1.retainSecret);
            const sourceCloudSecretNames = await this.getCloudFunctionSecretNames(functionName, sourceEnv);
            const sourceCloudSecrets = await this.ssmClientWrapper.getSecrets(sourceCloudSecretNames.map(name => secretName_1.getFullyQualifiedSecretName(name, functionName, sourceEnv)));
            sourceCloudSecrets.reduce((acc, { secretName, secretValue }) => {
                const shortName = secretName.slice(secretName_1.getFunctionSecretPrefix(functionName, sourceEnv).length);
                acc[shortName] = amplify_function_plugin_interface_1.setSecret(secretValue);
                return acc;
            }, destDelta);
            return destDelta;
        };
        this.getCloudFunctionSecretNames = async (functionName, envName) => {
            const prefix = secretName_1.getFunctionSecretPrefix(functionName, envName);
            const parts = path.parse(prefix);
            const unfilteredSecrets = await this.ssmClientWrapper.getSecretNamesByPath(parts.dir);
            return unfilteredSecrets.filter(secretName => secretName.startsWith(prefix)).map(secretName => secretName.slice(prefix.length));
        };
        this.doRemoveSecretsInCloud = (functionName) => {
            const isCommandPush = this.context.parameters.command === 'push';
            return !funcionStateUtils_1.isFunctionPushed(functionName) || isCommandPush;
        };
        this.isInteractive = () => { var _a, _b, _c; return !((_c = (_b = (_a = this.context) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.yes); };
    }
}
exports.FunctionSecretsStateManager = FunctionSecretsStateManager;
FunctionSecretsStateManager.getInstance = async (context) => {
    if (!FunctionSecretsStateManager.instance) {
        FunctionSecretsStateManager.instance = new FunctionSecretsStateManager(context, await ssmClientWrapper_1.SSMClientWrapper.getInstance(context));
    }
    return FunctionSecretsStateManager.instance;
};
const storeSecretsPendingRemoval = async (context, functionNames) => {
    functionNames.forEach(functionName => {
        const cloudSecretNames = exports.getLocalFunctionSecretNames(functionName, { fromCurrentCloudBackend: true });
        const localSecretNames = exports.getLocalFunctionSecretNames(functionName);
        const removed = cloudSecretNames.filter(name => !localSecretNames.includes(name));
        if (removed.length) {
            secretsPendingRemoval[functionName] = removed;
        }
    });
    await storeToBeRemovedFunctionsWithSecrets(context);
};
exports.storeSecretsPendingRemoval = storeSecretsPendingRemoval;
const defaultGetFunctionSecretNamesOptions = {
    fromCurrentCloudBackend: false,
};
const getLocalFunctionSecretNames = (functionName, options = defaultGetFunctionSecretNamesOptions) => {
    options = { ...defaultGetFunctionSecretNamesOptions, ...options };
    const parametersFilePath = path.join(options.fromCurrentCloudBackend ? amplify_cli_core_1.pathManager.getCurrentCloudBackendDirPath() : amplify_cli_core_1.pathManager.getBackendDirPath(), constants_1.categoryName, functionName, constants_2.functionParametersFileName);
    const funcParameters = amplify_cli_core_1.JSONUtilities.readJson(parametersFilePath, { throwIfNotExist: false });
    return (funcParameters === null || funcParameters === void 0 ? void 0 : funcParameters.secretNames) || [];
};
exports.getLocalFunctionSecretNames = getLocalFunctionSecretNames;
const setLocalFunctionSecretState = (functionName, secretDeltas) => {
    const existingSecrets = Object.keys(secretDeltaUtilities_1.getExistingSecrets(secretDeltas));
    const secretsParametersContent = {
        secretNames: existingSecrets,
    };
    const parametersFilePath = path.join(amplify_cli_core_1.pathManager.getBackendDirPath(), constants_1.categoryName, functionName, constants_2.functionParametersFileName);
    if (fs.existsSync(parametersFilePath)) {
        storeResources_1.createParametersFile(secretsParametersContent, functionName, constants_2.functionParametersFileName);
    }
    if (secretDeltaUtilities_1.hasExistingSecrets(secretDeltas)) {
        setAppIdForFunctionInTeamProvider(functionName);
    }
    else {
        removeAppIdForFunctionInTeamProvider(functionName);
    }
};
const setAppIdForFunctionInTeamProvider = (functionName) => {
    var _a, _b, _c, _d;
    const tpi = amplify_cli_core_1.stateManager.getTeamProviderInfo(undefined, { throwIfNotExist: false, default: {} });
    const env = (_a = amplify_cli_core_1.stateManager.getLocalEnvInfo()) === null || _a === void 0 ? void 0 : _a.envName;
    let funcTpi = (_d = (_c = (_b = tpi === null || tpi === void 0 ? void 0 : tpi[env]) === null || _b === void 0 ? void 0 : _b.categories) === null || _c === void 0 ? void 0 : _c[constants_1.categoryName]) === null || _d === void 0 ? void 0 : _d[functionName];
    if (!funcTpi) {
        lodash_1.default.set(tpi, [env, 'categories', constants_1.categoryName, functionName], {});
        funcTpi = tpi[env].categories[constants_1.categoryName][functionName];
    }
    lodash_1.default.assign(funcTpi, { [secretName_1.secretsPathAmplifyAppIdKey]: secretName_1.getAppId() });
    amplify_cli_core_1.stateManager.setTeamProviderInfo(undefined, tpi);
};
const removeAppIdForFunctionInTeamProvider = (functionName) => {
    var _a;
    const tpi = amplify_cli_core_1.stateManager.getTeamProviderInfo(undefined, { throwIfNotExist: false, default: {} });
    const env = (_a = amplify_cli_core_1.stateManager.getLocalEnvInfo()) === null || _a === void 0 ? void 0 : _a.envName;
    lodash_1.default.unset(tpi, [env, 'categories', constants_1.categoryName, functionName, secretName_1.secretsPathAmplifyAppIdKey]);
    amplify_cli_core_1.stateManager.setTeamProviderInfo(undefined, tpi);
};
const storeToBeRemovedFunctionsWithSecrets = async (context) => {
    const resourceStatus = await context.amplify.getResourceStatus(constants_1.categoryName);
    const resourcesToBeDeleted = ((resourceStatus === null || resourceStatus === void 0 ? void 0 : resourceStatus.resourcesToBeDeleted) || []);
    const deletedLambdas = resourcesToBeDeleted
        .filter(resource => resource.service === "Lambda")
        .map(resource => resource.resourceName);
    for (const deletedLambda of deletedLambdas) {
        const cloudSecretNames = await exports.getLocalFunctionSecretNames(deletedLambda, { fromCurrentCloudBackend: true });
        const localSecretNames = await exports.getLocalFunctionSecretNames(deletedLambda);
        const secretNames = Array.from(new Set(cloudSecretNames.concat(localSecretNames)));
        if (secretNames.length) {
            secretsPendingRemoval[deletedLambda] = secretNames;
        }
    }
};
//# sourceMappingURL=functionSecretsStateManager.js.map